/* ~This file is part of the Aliro library~

Copyright (C) 2023 Epistasis Lab, 
Center for Artificial Intelligence Research and Education (CAIRE),
Department of Computational Biomedicine (CBM),
Cedars-Sinai Medical Center.

Aliro is maintained by:
    - Hyunjun Choi (hyunjun.choi@cshs.org)
    - Miguel Hernandez (miguel.e.hernandez@cshs.org)
    - Nick Matsumoto (nicholas.matsumoto@cshs.org)
    - Jay Moran (jay.moran@cshs.org)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
// import React from "react";
// import { mount, configure } from "enzyme";
// import Adapter from "enzyme-adapter-react-16";
// import { act } from "react-dom/test-utils";
// import { FileUploadOrigin } from "./"; // Named export 사용

// // Setup JSDOM
// import { JSDOM } from "jsdom";

// const dom = new JSDOM("<!doctype html><html><body></body></html>", {
//   url: "http://localhost",
//   pretendToBeVisual: true,
// });

// global.document = dom.window.document;
// global.window = dom.window;
// global.navigator = {
//   userAgent: "node.js",
// };
// global.requestAnimationFrame = function (callback) {
//   return setTimeout(callback, 0);
// };
// global.cancelAnimationFrame = function (id) {
//   clearTimeout(id);
// };

// // Mock Blob and File
// global.Blob = class {
//   constructor(content, options) {
//     this.content = content;
//     this.options = options;
//     this.size = content.reduce((acc, val) => acc + val.length, 0);
//     this.type = options.type || "";
//   }
// };

// global.File = class extends Blob {
//   constructor(content, filename, options) {
//     super(content, options);
//     this.name = filename;
//     this.lastModified = new Date().getTime();
//   }
// };

// configure({ adapter: new Adapter() });

// describe("basic testing of FileUploadOrigin react component", () => {
//   let wrapper;
//   let instance;
//   let badFakeFile = new File([""], "iris.txt", { type: "text/plain" });
//   let container;

//   beforeEach(() => {
//     container = document.createElement("div");
//     document.body.appendChild(container);

//     act(() => {
//       wrapper = mount(<FileUploadOrigin />, { attachTo: container });
//     });

//     instance = wrapper.instance();
//   });

//   afterEach(() => {
//     wrapper.unmount();
//     document.body.removeChild(container);
//     container = null;
//   });

//   it("DONE - test instance", () => {
//     expect(instance).not.toBeNull();
//     if (typeof instance.instanceTest === "function") {
//       expect(instance.instanceTest()).toEqual("foobar");
//     }
//     expect(instance.state.testStateValue).toEqual("foobar");
//   });

//   it("DONE - FileUploadOrigin component, test for existence", () => {
//     expect(wrapper.find(FileUploadOrigin)).toHaveLength(1);
//     wrapper.setProps({ name: "bar" });
//     expect(wrapper.name()).toEqual("FileUploadOrigin");
//     expect(wrapper.props().name).toEqual("bar");
//   });

//   it("DONE - full component snapshot", () => {
//     expect(wrapper).toMatchSnapshot();
//   });

//   it("DONE - check UI form is hidden w/o a file selection", () => {
//     let formBody = wrapper.find("#file-upload-form-input-area");
//     expect(formBody.exists()).toBe(true);
//     expect(formBody.hasClass("file-upload-form-hide-inputs")).toEqual(true);
//     expect(formBody.hasClass("file-upload-form-show-inputs")).toEqual(false);
//   });

//   it("TODO - try selecting non-csv/tsv file type", () => {
//     const dropzoneComponent = wrapper.find("Dropzone");
//     expect(dropzoneComponent).toHaveLength(1);

//     act(() => {
//       dropzoneComponent.prop("onDropRejected")([badFakeFile]);
//     });

//     wrapper.update();

//     expect(wrapper.state("selectedFile")).toBeNull();
//     let formBody = wrapper.find("#file-upload-form-input-area");
//     expect(formBody.hasClass("file-upload-form-hide-inputs")).toEqual(true);
//     expect(formBody.hasClass("file-upload-form-show-inputs")).toEqual(false);
//   });

//   // 추가적인 테스트 케이스들...

//   it("test file selection with valid CSV file", () => {
//     const validCsvFile = new File(
//       ["column1,column2\nvalue1,value2"],
//       "test.csv",
//       { type: "text/csv" }
//     );
//     const dropzoneComponent = wrapper.find("Dropzone");

//     act(() => {
//       dropzoneComponent.prop("onDropAccepted")([validCsvFile]);
//     });

//     wrapper.update();

//     expect(wrapper.state("selectedFile")).not.toBeNull();
//     expect(wrapper.state("selectedFile").name).toEqual("test.csv");

//     let formBody = wrapper.find("#file-upload-form-input-area");
//     expect(formBody.hasClass("file-upload-form-show-inputs")).toEqual(true);
//   });

//   it("test dependent column selection", () => {
//     // 먼저 유효한 파일을 선택하여 UI를 활성화합니다
//     const validCsvFile = new File(
//       ["column1,column2\nvalue1,value2"],
//       "test.csv",
//       { type: "text/csv" }
//     );
//     act(() => {
//       wrapper.find("Dropzone").prop("onDropAccepted")([validCsvFile]);
//     });
//     wrapper.update();

//     // 대상 열 선택 드롭다운을 찾아 선택을 변경합니다
//     const depColDropdown = wrapper.find("#target_dropdown");
//     act(() => {
//       depColDropdown.prop("onChange")(null, { value: "column1" });
//     });
//     wrapper.update();

//     // 상태가 올바르게 업데이트되었는지 확인합니다
//     expect(wrapper.instance().getDependentColumn()).toEqual("column1");
//   });
// });

// origin
import FileUploadOrigin from ".";
//import SceneHeader from '../SceneHeader';
// try getting react pieces and framework for test rendering
import React from "react";
import configureStore from "redux-mock-store";
import thunk from "redux-thunk";

const middlewares = [thunk];
const initialState = {};
const mockStore = configureStore(middlewares);

import { shallow, mount, render, configure } from "enzyme";
import Adapter from "enzyme-adapter-react-16";
configure({ adapter: new Adapter() });

//// NOTE on getting state
//
// The enzyme wrapper method 'state' (and related methods) is not working on mount(<my component>).
// I think it's because the component is wrapped with redux connect().
// So you can use shallow(<my component>).dive().state(),
//  or more direclty shallow(<my component>).dive().instance().state
// I don't know which is better.
//
describe("basic testing of FileUploadOrigin react component", () => {
  let store = mockStore(initialState);
  let fullDom;
  let shallowDom;
  let instance;
  let badFakeFile = { name: "iris.txt" };
  // basic bookkeeping before/after each test; mount/unmount component, should be
  // similar to how piece will actually work in browser
  beforeEach(() => {
    fullDom = mount(<FileUploadOrigin store={store} testProp="hello" />);
    //NOTE with react-redux, need 'dive()' to get the 'true' (not sure of the term) component instance.
    shallowDom = shallow(<FileUploadOrigin store={store} />).dive();
    instance = shallowDom.instance();
  });
  afterEach(() => {
    fullDom.unmount();
  });

  //test that the componement instance is viable
  //NOTE 'it' is an alias for 'test'
  it("DONE - test instance", () => {
    expect(instance).not.toEqual(null);
    //Test calling a method on the instance
    expect(instance.instanceTest()).toEqual("foobar");
    //Test retrieving state from the instance. See note above about accessing state.
    expect(instance.state.testStateValue).toEqual("foobar");
    expect(shallowDom.state("testStateValue")).toEqual("foobar");
  });

  // test for existence
  it("DONE - FileUploadOrigin component, test for existence", () => {
    //console.log('jest console log!'); //this works, outputs to console at test script runtime
    // Find the component itself
    expect(fullDom.find(FileUploadOrigin)).toHaveLength(1);
    fullDom.setProps({ name: "bar" });
    expect(fullDom.name()).toEqual("Connect(FileUploadOrigin)");
    expect(fullDom.props().testProp).toEqual("hello");
    expect(fullDom.props().name).toEqual("bar");
  });

  //snapshot of component
  //I believe shallow is better since it won't include child components
  it("DONE - full component snapshot", () => {
    expect(
      shallow(<FileUploadOrigin store={store} />).dive()
    ).toMatchSnapshot();
  });

  // the intended behavior of this component is to hide the fields to enter info
  // about the file being uploaded until a file with a testFilename has been selected
  it("DONE - check UI form is hidden w/o a file selection", () => {
    let formBody = shallowDom.find("#file-upload-form-input-area");
    expect(formBody.length).toEqual(1);

    // check for CSS style which hides form
    expect(formBody.hasClass("file-upload-form-hide-inputs")).toEqual(true);
    expect(formBody.hasClass("file-upload-form-show-inputs")).toEqual(false);
  });

  it("TODO - try selecting non-csv/tsv file type", () => {
    let dropzoneButton = fullDom.find("#file-dropzone");
    expect(dropzoneButton).toHaveLength(1);
    // Simulate callback receiving bad file obj
    dropzoneButton.at(0).prop("onDropAccepted")([badFakeFile]);
    // Should not have changed file object
    expect(shallowDom.state("selectedFile")).toBeNull();
    // Check the UI isn't showing for file specifications
    let formBody = fullDom.find("#file-upload-form-input-area");
    // check for CSS style which hides form
    expect(formBody.hasClass("file-upload-form-hide-inputs")).toEqual(true);
    expect(formBody.hasClass("file-upload-form-show-inputs")).toEqual(false);
  });
}); //describe
